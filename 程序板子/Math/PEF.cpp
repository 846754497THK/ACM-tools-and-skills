/*
    期望-势能函数
*/
/*
    Problem：
        有n个节点，每个节点有两种状态：选中和未选中。
        每个选中的点后面都跟着若干个（可能是0个）未选中的点。每个未选中的点都一定跟在某个选中的点后面。
        每次操作随机选择两个被选中的点，随机将其中一个变成未选中，且跟在另一个后面，
        同时将跟在他后面的节点全部改为选中。求这样操作下去，直到最后只剩一个选中的点的期望步数。
    Solution：
        设一个点后面跟着k个被选中的点，设其的势能函数为：2^k−1
        那么目标状态的势能函数值就是2^(n−1)−1
        对每一次操作，计算它的势能函数期望变化量，
        Δ=1/2*((2^(p+1)−1)−(2^p−1)−(2^q−1))+1/2*((2^(q+1)−1)−(2^p−1)−(2^q−1))=1
        势能函数期望变化量为1，所以期望步数即势能函数差值
        整个的期望步数就是目标状态的势能函数，减去当前状态的势能函数
*/
#include <bits/stdc++.h>
using namespace std;
const int N = 510, P = 1e9 + 7;
int n, x, pw[N], cnt[N];
int main() {
    scanf("%d", &n);
    pw[0] = 1;
    for (int i = 1; i <= n; i++) pw[i] = pw[i - 1] * 2 % P;
    for (int i = 1; i <= n; i++) {
        scanf("%d", &x);
        if (~x) cnt[x]++;
    }
    int ans = pw[n - 1] - 1;
    for (int i = 1; i <= n; i++) ans = (ans - (pw[cnt[i]] - 1)) % P;
    printf("%d\n", (ans + P) % P);
    return 0;
}